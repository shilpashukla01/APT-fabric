<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <link rel="stylesheet" href="http://ajax.googleapis.com/ajax/libs/jqueryui/1.8.16/themes/base/jquery-ui.css" type="text/css" media="all" />
    <script src="js/fabric-modified.js"></script>
    <script src="js/fabric-PermGroup.js"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/jqueryui/1.8.16/jquery-ui.min.js"></script>
    <script src="js/json2.js"></script>
    <style>
      html, body {
    	 margin:0;
    	 padding:0;
    	 overflow:hidden;
      }

     .vmenu{border:1px solid #aaa;position:absolute;background:#fff;  display:none;font-size:0.75em;}
     .vmenu .first_li span{width:100px;display:block;padding:5px 10px;cursor:pointer}
     .vmenu .inner_li{display:none;margin-left:120px;position:absolute;border:1px solid #aaa;border-left:1px solid #ccc;margin-top:-28px;background:#fff;}
     .vmenu .sep_li{border-top: 1px ridge #aaa;margin:5px 0}
     .vmenu .fill_title{font-size:11px;font-weight:bold;/height:15px;/overflow:hidden;word-wrap:break-word;}

     #state { width: 70px; height: 25px; position: fixed; background-color:'#FFFFFF'; border:1px solid black; font-size:9pt; font-family: Arial, sans-serif;z-index:101; display:none;text-align:center;}
    </style>

    </head>
    <body id='body'>
      <div class="vmenu" id="original" style="display:none;">
        <div class="first_li" id="edit"><span>Edit metadata</span></div>
        <div class="first_li" id="groupadd"><span>Add to group</span></div>
        <div class="first_li" id="groupremove"><span>Remove from group</span></div>
      </div>
      <script>
var log = function() {
    this.suppressErrors = false;
    this.suppressWarnings = true;
    this.suppressActions = true;

    this.error = function(msg) {
      if (!this.suppressErrors) {
        console.log("[error] " + msg);
      }
    }

    this.warning = function(msg) {
      if (!this.suppressWarnings) {
        console.log("[warning] " + msg);
      }
    }

    this.action = function() {
      if (!this.suppressActions) {
        console.log("[action] " + msg);
      }
    }

    };

/* Takes in a function method, returns a duplicate scoped to object.
   So 'this' will point to object. Helpful for things like event
   handler functions that are scoped to DOMWindow or document despite
   being called inside an object. */
function createBoundedWrapper(object, method) {
  return function() {
    return method.apply(object, arguments);
  };
}


/* Group class. Container for fabric.PermGroup */

function Group(workspace) {
  this.workspace = workspace;
  this.items = [];
  this.title = undefined;
  this.fabric = new fabric.Group();
}

Group.prototype.add = function(item) {
  this.items.push(item);
  this.fabric.add(item.fabric);
}

Group.prototype.remove = function(id) {
  this.items.remove(this.items[id]);
  this.fabric.remove(this.items[id].fabric);
}

/* Our Item object. Represents individual documents. */

function Item(workspace, imageURL) {
  this.imageURL = imageURL;
  this.workspace = workspace;
  this.id = ++this.workspace.numItems;
  this.title = "a letter";
  this.description = "a letter...";

/* This is called once fabric creates a new Image object. 
  It's called using wrapper 'boundFabricImageCallback' to change scope. */
  function fabricImageCallback(image) {
/* *** Need feedback function here to display loading progress
       since it takes a while. */

    image.set({
      left: 250,
      top: 250
    });
    this.workspace.canvas.add(image);

    image.lockUniScaling = true;

    // This saves it to our object.
    this.fabric = image;
    this.fabric.item = this;

    // If all the items are loaded, render the canvas and change state
    if (++this.workspace.loadedItems >= this.workspace.numItems) {
      this.workspace.canvas.renderAll();
      this.workspace.changeState('ready');
    }

  }

  // Bound wrapper for private method fabricImageCallback
  var boundFabricImageCallback = createBoundedWrapper(this, fabricImageCallback);

  // Create new fabric Image object for our item.
  fabric.Image.fromURL(imageURL, boundFabricImageCallback);

}

/* Workspace object is the overall container object. Fabric canvas is kept inside it, 
so are all Items and functions for loading/saving */
function Workspace() {
  this.items = [];
  this.groups = [];
  this.loadedItems = 0;
  this.numItems = 0;
  this.initialized = false;
  this.id = 1;
  this.lastMouseDown = {};

  this.uiElements = [];

  var boundLoadSVGFromURLCallback = createBoundedWrapper(this, loadFromSVGFromURLCallback);

/* This function processes the workspace JSON returned from our request to the server.
  Run using a bounded wrapper. */
  this.processJSON = function(data) {
/*
    if(data.initialized == false) {
      var totalArea = this.canvas.width*this.canvas.height;
      var fullItemArea = totalArea/numItems;

      // account for padding
      var actualItemArea = fullItemArea-(fullItemArea*.05);

    }
*/
      //for (i in data.items) {

    // add width, height, left, top to item constructor for
    var item = new Item(this, data.items[1].url);
    this.items.push(item);
    //}
  }

  this.render = function() {

  }

  this.initialRender = function() {

  }

  // If top & left are not included, item is just loaded, it does not display
  this.loadSVGFile = function(name, scale, width, height, top, left) {

    fabric.loadSVGFromURL('img/' + name + '.svg', function(svg) {
      boundLoadSVGFromURLCallback(svg, {
        name: name,
        width: width,
        scale: scale,
        height: height,
        top: top,
        left: left
      });
    });
  }

  // This loads and renders our UI
  this.loadUI = function() {
    this.loadUIElements();
    this.renderUI();
  }

  // This creates and renders the state feedback box in the lower right corner
  this.loadStateFeedback = function() {
    var offsetLeft = this.canvas.width - 85;
    var offsetTop = this.canvas.height - 40;

    this.stateDiv = document.createElement('div');
    this.stateDiv.appendChild(document.createElement('span'));
    this.stateDiv.setAttribute('id', 'state');
    this.stateDiv.setAttribute('style', 'left:' + offsetLeft + 'px;top:' + offsetTop + 'px;');
    $('#body').append(this.stateDiv);
    $(this.stateDiv).show();

  }

  // This function changes the state
  this.changeState = function(state) {
    this.state = state;

    switch (this.state) {
    case 'init':
      displayState = "Initializing...";
      break;
    case 'saved':
      displayState = "Saved";
      break;
    case 'saving':
      displayState = "Saving...";
      break;
    case 'modified':
      displayState = "Modified";
      break;
    case 'saveError':
      displayState = "Save error!";
      break;
    case 'ready':
      displayState = "Ready";
    }

    $("#state span").hide().html(displayState).show();
  }

  /* Load our interface elements from SVG files. */
  this.loadUIElements = function() {
    //this.loadSVGFile('folder', 1, 40, 40, 110, 1000);
    //this.loadSVGFile( 'rotate', .6, 20, 20 );
    this.loadSVGFile('plus', .7, 40, 40, 98, 1200);
    this.loadStateFeedback();
  }

  // Render all the UI elements in the workspace
  this.renderUI = function() {
    for (key in this.uiElements) {
      this.canvas.add(this.uiElements[key]);
    }

    this.canvas.renderAll();
  }

  this.createGroup = function() {
    var group = new Group(this);
    this.groups.push(group);
  }

  this.objectScalingEvent = function(e) {
    var target = e.memo.target;
    console.log(target.originalState);
    var diff = {};
        diff.x = target.scaleX - target.originalState.scaleX,
        diff.y = target.scaleY - target.originalState.scaleY;
    if(target.type == "perm-group") {
      target.forEachObject(function(child) {
        child.scale(target.scaleX);
      });
    }

  }

  this.objectMovingEvent = function(e) {
    var target = e.memo.target;

    var pointer = fabric.util.getPointer(e),
        x = pointer.x,
        y = pointer.y;

    // if target is perm group, move all objects inside with it
    if (target.type == "perm-group") {
      target.moveChildren();
    }

    var permGroup = this.canvas.isInsidePermGroup(target);
    if (permGroup) {
      permGroup.set({
        opacity: 1
      });
    } else {

      this.canvas.forEachObject(function(object) {
        if(object.type == "perm-group") {
          object.set({ opacity: .5 });
        }
      });
    }

   if(target.type == "perm-group") {
      target.set({ opacity: .5 });
    }

    this.canvas.calcOffset();
    this.canvas.renderAll();

/*
    if(target.isContainedWithinObject(this.canvas.item(0))) {
      this.canvas.item(0).set({opacity: .5});

    } else {
      this.canvas.item(0).set({opacity: 1});
    }
*/
  }

  this.objectSelectedEvent = function(e) {
    var target = e.memo.target;

    if(e.memo.target.type != "perm-group") {
    console.log("bring to front");
    this.canvas.bringToFront(target);
    }
  }

  function loadFromSVGFromURLCallback(objects, options) {
    var group = new fabric.PathGroup(objects, {
      left: options.left,
      top: options.top,
      width: options.width * 1.1,
      height: options.height * 1.1,
    });
    group.id = options.name;
    group.hasBorders = false;
    group.hasControls = false;
    group.selectable = true;
    group.scale(options.scale);
    this.uiElements[options.name] = group;
    if (options.top && options.left) {
      this.canvas.add(group);
    }
  }

  this.addGroup = function() {
    var group = new Group(this);
  }

  this.objectModifiedEvent = function(e) {
    this.changeState('modified');
    this.saveRemotely();
  }

  this.mouseDownEvent = function(e) {
    var object = e.memo.target;
    var rightNow = new Date();
    switch (object.id) {
    case 'folder':
      this.addGroup();
      break;
    }

    if (typeof this.lastMouseDown.time != 'undefined' && typeof this.lastMouseDown.object != 'undefined') {
      if (parseInt(rightNow.getTime() - this.lastMouseDown.time.getTime()) <= 800) {
        // if we get here it's a double click.
        object.item.renderMenu(e);
      }
    }

    var permGroup = this.canvas.isInsidePermGroup(object);
    if (permGroup) {
      permGroup.set({
        opacity: .5
      });
    }

    this.lastMouseDown.time = rightNow;
    this.lastMouseDown.object = e.memo.target;
  }

  this.mouseUpEvent = function(e) {

    var target = e.memo.target;

    // If there's an object being clicked on
    if (typeof target !== "undefined") {

      // Get the perm group the target is currently in
      var currentPermGroup = this.canvas.isInsidePermGroup(target);
      console.log(currentPermGroup);
      // If the object is in the perm group
      if (currentPermGroup) {

        // If the object is now in a different perm group than the one
        // it's currently linked to.
        if( typeof target.permGroup !== "undefined" && currentPermGroup.id !== target.permGroup.id ) {
          target.permGroup.remove(target);
          target.permGroup = currentPermGroup;

        }

        if (!currentPermGroup.contains(target)) {
          currentPermGroup.add(target);
          currentPermGroup.set({ opacity: .5 });
        }
      }

      if (target.permGroup != null && !target.isContainedWithinObject(target.permGroup)) {
        console.log("remove from permgroup.");
        target.permGroup.remove(target);
        target.permGroup.set({ opacity: .5 });
      }

      this.canvas.renderAll();

      if (this.state == "modified") {
        this.saveRemotely();
      }
    }
  }

  this.saveSuccessCallback = function(data) {
    this.changeState('saved');
  }

}

Item.prototype.renderMenu = function(e) {
  var vmenu = $("#original.vmenu").clone().attr('id', this.id);
  $(vmenu).children().click(function() {
    this.workspace.renderUIElement(this.getAttribute('id'), this.id);
  });

  $(vmenu).css({
    left: e.memo.e.pageX,
    top: e.memo.e.pageY,
    zIndex: '101'
  }).appendTo('#body').show();

}

/* Return a JSON object for sending to the server for saving.
   Set returnString to true if you want a JSON string instead of an object. */
Item.prototype.toJSON = function(returnString) {
  returnString = typeof returnString !== 'undefined' ? returnString : false;

  var jsonItem = {};
  jsonItem.id = this.id;
  jsonItem.title = this.title;
  jsonItem.description = this.description;
  jsonItem.imageURL = this.imageURL;
  jsonItem.fabric = this.fabric;

  if (returnString) {
    return JSON.stringify(jsonItem);
  } else {
    return jsonItem;
  }
}


/* Send current workspace state to server for saving. */
Workspace.prototype.saveRemotely = function() {
  this.changeState('saving');

  var boundSaveSuccessCallback = createBoundedWrapper(this, this.saveSuccessCallback);
  var tempWorkspace = {};

  tempWorkspace.id = this.id;
  tempWorkspace.initialized = this.initialized;
  tempWorkspace.title = "";
  tempWorkspace.items = [];
  for (var i = 0; i < this.numItems; i++) {
    tempWorkspace.items[i] = this.items[i].toJSON();
  }
  var jsonString = JSON.stringify(tempWorkspace);

  // Error handling for this request is non-existent currently.
  $.post('http://localhost/apt/json.php', {
    id: this.id,
    content: jsonString
  }, boundSaveSuccessCallback);


}

Workspace.prototype.init = function() {

  // Bounded wrappers for Workspace functions
  var boundZoom = createBoundedWrapper(this, this.zoom);
  var boundLoadUI = createBoundedWrapper(this, this.loadUI);
  var boundProcessJSON = createBoundedWrapper(this, this.processJSON);
  var boundMouseDownEvent = createBoundedWrapper(this, this.mouseDownEvent);
  var boundMouseUpEvent = createBoundedWrapper(this, this.mouseUpEvent);
  var boundObjectModifiedEvent = createBoundedWrapper(this, this.objectModifiedEvent);
  var boundObjectMovingEvent = createBoundedWrapper(this, this.objectMovingEvent);
  var boundObjectSelectedEvent = createBoundedWrapper(this, this.objectSelectedEvent);
  var boundObjectScalingEvent = createBoundedWrapper(this, this.objectScalingEvent);

  // This is our main canvas element. Create and append it.
  var canvasElem = document.createElement('canvas');
  canvasElem.setAttribute('id', 'c');
  canvasElem.setAttribute('width', window.innerWidth);
  canvasElem.setAttribute('height', window.innerHeight);
  canvasElem.setAttribute('style', "border:1px solid #ccc");
  document.getElementById('body').appendChild(canvasElem);

  // This is our FabricJS object for the canvas.
  this.canvas = new fabric.Canvas('c', {
    renderOnAddition: false
  });

  //this.canvas.observe('mouse:down', boundMouseDownEvent);
  this.canvas.observe('object:modified', boundObjectModifiedEvent);
  this.canvas.observe('object:moving', boundObjectMovingEvent);
  this.canvas.observe('object:selected', boundObjectSelectedEvent);
  this.canvas.observe('object:scaling', boundObjectScalingEvent);

  // fabric.js mouse events
  this.canvas.observe('mouse:up', boundMouseUpEvent);

  // Default zoom scale
  this.zoomScale = 1;

  this.loadUI();
  this.changeState('init');

  var permgroup = new fabric.PermGroup({
    width: 50,
    height: 50,
    left: 750,
    top: 50,
    fill: fabric.util.generateRGB(),
    opacity: .5,
    id: 1
  });

  var permgroup2 = new fabric.PermGroup({
    width: 50,
    height: 50,
    left: 250,
    top: 50,
    fill: fabric.util.generateRGB(),
    opacity: .5,
    id: 2

  });

  var circleNav = new fabric.Circle({
    radius: 50,
    left: 1200,
    top: 70,
    fill: 'rgb(255,255,255)',
    stroke: 'rgb(0,0,0)'
  });
  circleNav.lockUniScaling = true;

  var circleCenter = new fabric.Circle({
    radius: 7,
    left: 1200,
    top: 70,
    fill: 'rgb(0,0,0)',
    scaleable: false
  });
  //  circleNav2.lockUniScaling = true;
  var dividingLine1 = new fabric.Line([1163, 35, 1237, 105], {
    stroke: "#000000",
    strokeWidth: 2,
    scaleable: false
  });

  var dividingLine2 = new fabric.Line([1237, 35, 1163, 105], {
    stroke: "#000000",
    strokeWidth: 2,
    scaleable: false
  });

  this.canvas.add(circleNav);
  this.canvas.add(circleCenter);
  this.canvas.add(dividingLine1);
  this.canvas.add(dividingLine2);

  //var circleGroup = new fabric.Group([circleNav, circleCenter, dividingLine1, dividingLine2]);

  permgroup.selectable = true;
  permgroup.hasBorders = true;
  permgroup.hasControls = true;
  permgroup2.selectable = true;
  permgroup2.hasBorders = true;
  permgroup2.hasControls = true;


  this.canvas.add(permgroup);
  this.canvas.add(permgroup2);

  // Event listener for zoom.
  document.addEventListener('DOMMouseScroll', boundZoom, false);

  var apiURL = "http://localhost/apt/json.php";

  $.getJSON("json.json", {
    //$.getJSON("http://localhost/apt/json.php", {
    workspace: '1'
  }, boundProcessJSON);

}

Workspace.prototype.zoom = function(event) {
  var group = new fabric.Group(this.canvas.getObjects());
  group.selectable = false;
  group.hasBorders = false;
  group.hasControls = false;

  var groupObjects = group.getObjects();
  for (i in groupObjects) {
    groupObjects[i].hasBorders = false;
  }

  if (event.detail > 0) {
    this.zoomScale = this.zoomScale - .05;
  } else if (event.detail < 0) {

    this.zoomScale = this.zoomScale + .05;
  }

  this.canvas.setActiveGroup(group);
  group.scale(this.zoomScale);

  this.canvas.renderAll();
  this.canvas.discardActiveGroup();

  var groupObjects = group.getObjects();
  for (i in groupObjects) {
    groupObjects[i].hasBorders = true;
  }

}

/*** MAIN PROGRAM EXECUTION BODY ***/

var workspace = new Workspace();

workspace.init();

/***                             ***/

    </script>
  </body>
</html>